<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>画图</title>
	<style>
      canvas {
          border: 2px solid #f0f;
          display: block;
          margin: auto;
      }
	</style>
</head>
<body>
<canvas width="500" height="500"></canvas>
</body>
<script>
    var canvas = document.querySelector('canvas')
    canvas.style.imageRendering = 'pixelated' //放大时的插帧方式：不插帧，直接放大像素
    var ctx = canvas.getContext('2d')

    function dot(x, y, color = 'black') {
        x = Math.round(x)
        y = Math.round(y)
        ctx.fillStyle = color
        ctx.fillRect(x, y, 1, 1)
    }
</script>
<script>
    // 不可更改上面的代码
    // 你的代码写在这里
    // YOUR CODE GOES BELOW
    //  * YOUR TASK
    //  * 在 坐标 (42, 42) 画出一个点
    dot(42, 42, '#FF6A00')
    //
    //  * 画一条实线
    for (let i = 42; i < 100; i++) {
        dot(i, 44, '#FF6A00')
    }
    //  * 画一条一个实点一个空点的虚线
    for (let i = 42; i <= 100; i += 2) {
        dot(i, 46, '#FF6A00')
    }
    //  * 画一条两个实点两个空点的虚线
    for (let i = 42; i <= 100; i += 4) {
        dot(i, 48, '#FF6A00')
        dot(i + 1, 48, '#FF6A00')
    }
    //  * 画一条三个实点两个空点的虚线
    for (let i = 42; i <= 100; i += 5) {
        dot(i, 50, '#FF6A00')
        dot(i + 1, 50, '#FF6A00')
        dot(i + 2, 50, '#FF6A00')
    }
    //  * 画一条45度的斜线
    for (let i = 42; i <= 100; i++) {
        dot(i, 10 + i, '#FF6A00')
    }
    //  * 画一条30度的斜线（与x轴或y轴的夹角呈30度）
    {
        let ox = 42, oy = 112
            , x = ox, y = oy, tmp = 86 / 50
        while (x < ox + 50 && y < oy + 86.6) {
            dot(x, y, '#FF6A00')
            x++
            y += tmp
        }
    }
    //  * 画一条跨越画布左上角和右下角的对角线
    {
        let ox = 0, oy = 0
        while (ox <= 500 && oy <= 500) {
            dot(ox, oy, '#FF6A00')
            ox++
            oy++
        }
    }
    //  * 画一个空心矩形
    {
        let ox = 42, oy = 215
            , x = ox, y = oy
        while (x <= 92) {
            while (y <= 265) {
                if (x === ox || y === oy || x === ox + 50 || y === oy + 50) dot(x, y, '#FF6A00')
                y++
            }
            y = oy
            x++
        }
    }
    //  * 画一个实心矩形
    {
        let x = 42, y = 270
        while (x <= 92) {
            while (y <= 320) {
                dot(x, y, '#FF6A00')
                y++
            }
            y = 270
            x++
        }
    }

    //  * 画两个个空心的圆，居中：
    //  * 一个半径为50像素
    //  * 一个半径为200像素
    {
        let r = 50, ox = 250, oy = 250
        for (let deg = 0; deg <= 360; deg++) {
            let x = ox + r * Math.sin(deg * Math.PI / 180)
                , y = oy + r * Math.cos(deg * Math.PI / 180)
            dot(x, y, '#ff6a00')

        }
        r = 200
        for (let deg = 0; deg <= 360; deg++) {
            let x = ox + r * Math.sin(deg * Math.PI / 180)
                , y = oy + r * Math.cos(deg * Math.PI / 180)
            dot(x, y, '#ff6a00')

        }
    }
    //  * 画一个实心的圆，半径至少为100像素
    {
        let or = 100, ox = 400, oy = 100
        for (let deg = 0; deg <= 360; deg++) {
            for (let r = 1; r <= or; r++) {
                let x = ox + r * Math.sin(deg * Math.PI / 180)
                    , y = oy + r * Math.cos(deg * Math.PI / 180)
                dot(x, y, '#FF6A00')
            }
        }
    }
    //  * 画一个【大小合适】的sin(x)的图像
    {
        let ox = 0, oy = 250
        for (let x = ox; x <=500 ;x++) {
            dot(x*Math.tan(Math.PI/3),500-x,'orange')
        }
    }
    //  * 画出rgb色彩空间的某一面（尺寸要大于100x100）
    //  如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变幻后的色彩空间某一面
    //  可以考虑如下几种矩阵：
    //  2 0
    //  0 2
    //  ------
    //  1  0.27
    //  0  1
    //  ------
    //  0.5    0.87
    //  -0.87  0.5
    {
        let ox = 100, oy = 270
        for (let i = 1; i <= 128; i+=1) {
            for (let j = 1; j <= 128; j+=1) {
                dot(i*1+j*0+ox,i*0.27+j*1+oy,`rgb(${i},0,${j})`)
            }
        }

    }

</script>
</html>
